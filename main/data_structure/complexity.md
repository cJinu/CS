# 복잡도

> 복잡도는 시간 복잡도와 공간 복잡도로 나뉩니다.

## 5.1.1 시간 복잡도

- 컴퓨터 프로그램의 입력값과 연산 수행 시간의 상관관계를 나타내는 척도
- 시간 복잡도란 크기 n의 모든 입력에 대해 걸리는 최대의 시간(최악의 경우)
- 시간 개념보다는 알고리즘이 실행될 때 동작하는 연산의 횟수가 몇번인지 세는것
- 성능평가 유형으로 best, average, worst 가 있는데 이 중 최악의 경우로 알고리즘 성능을 평가

### BigO 표기법
--- 
시간복잡도란 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계를 가르킴 <br>
어떠한 알고리즘 로직이 **얼마나 오랜 시간**이 걸리는지를 나타내는 데 쓰이며 이때 주로 사용되는 것이 빅오 표기법이다.




예를 들어 입력의 크기가 n인 모든 입력에 대한 2중 for 문을 실행해보자
``` java
int O = 0;
for(int i = 0; i < n; i++){
    for(int j = 0; j < n; j++){
        System.out.print(O + " ");
    }
}

for(int i = 0; i < 2*n + 10; i++){
    System.out.print("BigO ");
}

// 1 2 3 4 5 .... n^2-1 n^2
// BigO ... BigO
// 이런 결과가 출력 될 것 이다.
```
이때 시간 복잡도를 계산해보자면 O(n^2 + 2n + 10) <br>
상수항 무시, 영향력 없는 항 무시하는 빅오의 표기법 <br>
O(n^2)의 시간 복잡도를 가지게 된다.


![image](https://github.com/cJinu/CS/assets/94429120/ac567dd2-4b57-491b-b59b-4fb974caf82d)

### 왜 빅오 표기법이 알고리즘 성능의 척도일까?
1. 알고리즘 효율성의 상한선 기준으로 표기
2. 최악의 경우여도 Big-O 만큼의 성능을 보장
3. 알고리즘이 항상 최선의 결과만을 가지지 않기 때문


## 시간 복잡도의 존재 이유
- 소프트웨어 개발이란 컴퓨터라는 강력한 성능의 계산기를 이용해 주어진 문제를 해결하는 작업이다. 
- 그런데 어떠한 문제의 답을 계산하는 방법은 한 가지가 아닐 수 있다. 
- 시간복잡도는 다양한 풀이법(알고리즘) 중에 어느 것이 더 효율적인지를 판별하기 위해 만든
것이다.

## 5.1.2 공간 복잡도
공간 복잡도란 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양 <br>
이때 공간 복잡도를 두가지로 나눌 수 있다.

1. 알고리즘과 무관한 공간, 고정 공간: 코드가 저장되는 공간, 시스템이 필요로 하는 공간
2. 알고리즘과 밀접한 공간, 가변 공간: ArrayList, Stack과 같은 변수를 저장하는 공간

> 공간 복잡도는 보통 중요하게 생각하지 않는 경우가 많지만, 많은 데이터를 다루는 경우 공간 복잡도가 커지게 되면 프로그램이 메모리에 올라가지 않아 실행할 수 없게 될 수도 있다.
따라서 알고리즘 작성 시 공간 복잡도도 어느 정도 신경 써서 작성하는 것이 좋다 !!

### 시간 복잡도 vs 공간 복잡도
시간 복잡도는 얼마나 빠르게 실행되는지, 공간 복잡도는 얼마나 많은 자원(메모리 공간)이 필요한지를 판단한다.

시간 복잡도와 공간 복잡도는 반비례하는 경향이 있어, 보통 알고리즘의 성능을 판단할 때는 시간 복잡도를 위주로 판단한다.


### 자료구조에 따른 시간복잡도

![image](https://github.com/cJinu/CS/assets/94429120/0d5d0c53-d711-47bc-b9c5-4b0820746755)