# 데이터베이스의 종류

# 관계형 데이터베이스(RDBMS)

- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- SQL 언어를 사용하여 조작
- MySQL, PostgreSQL, Oracle, SQL server, MSSQL

## MySQL

- C, C++ 기반
- MYISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스 제공
- 대용량 데이터베이스를 위해 설계
- 롤백, 커밋, 이중 암호 지원 보안 등의 기능 제공
- 쿼리 호출 단계
  1. 구문 분석(Parsing)
  2. 최적화(Optimizing)
  3. 실행(Executing)
- 쿼리 캐시 지원 → 입력된 쿼리 문에 대한 전체 결과 집합 저장 → 위의 3단계 건너뜀
- MySQL 스토리지 엔진 아키텍처

![image](https://github.com/cJinu/CS/assets/38110757/2683ca74-e6ac-44ff-ae83-3e119d61e931)

### 스토리지 엔진

- DBMS가 데이터베이스에 대해 데이터를 CRUD(삽입, 추출, 업데이트 및 삭제) 하는 데 사용하는 기본 소프트웨어 컴포넌트
- InnoDB
  - MySQL 5.5 이후 기본 스토리지 엔진
  - 커밋, 롤백, 및 충돌 복구 기능 제공
  - 트랜잭션 제공
  - Foreign Key 지원
  - MVCC 지원 → 다중 사용자 동시성
  - 데이터 무결성
- 모듈식 아키텍처 → 쉽게 스토리지 엔진 변경 가능
- 데이터 웨어하우징: https://likeyoung.tistory.com/entry/datawarehouse
- 고가용성 처리: 서버, 네트워크, 프로그램 등의 정보 시스템이 상당히 오랜 기간 동안 지속적으로 정상 운영이 가능한 성질

# NoSQL 데이터베이스

- Not Only SQL
- 대량의 분산된 데이터를 저장하고 조회하는 것에 특화 ← 스키마 X
- 데이터 간 관계 정의 X → JOIN 연산 불가
- 관계형 DBMS에 비해 대용량 데이터 저장 가능
- 데이터를 분산 저장 → 특정 서버에 장애가 발생했을 때도 데이터 손실 및 서비스 오류를 방지
- 유동적인 스키마 → 데이터를 저장하는 컬럼이 각기 다른 이름과 데이터 타입을 가져도 됨

![image](https://github.com/cJinu/CS/assets/38110757/3062cb2d-1515-4d99-918f-70e7fd2b6360)

## 장점

- 저렴한 비용으로 분산 처리와 병렬 처리 가능
- 설계 비용 감소
- 빅데이터 처리에 효과적
- 가변적인 구조로 데이터 저장 가능 및 모델의 유연한 변화 가능

## 단점

- 데이터 일관성 보장 X

## MongoDB

- Document 지향의 데이터베이스
- (field, value) 쌍의 JSON 타입의 document
- 데이터베이스 내에서 저장될 때는 BSON 타입의 바이너리 형태

![image](https://github.com/cJinu/CS/assets/38110757/5bc8dc9e-e15e-4562-88dd-1d406a4ff1d1)

- document - collection - database
- record - table - database

# 인덱스

# 정의

- 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- index == 책의 색인
- 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
- 인덱스를 통해 PK 탐색 → PK를 통해 레코드를 탐색
- select 뿐만 아니라 update, delete 의 속도도 향상 ← 결국 조회해야하기 때문
- index X → Full Scan(전체 탐색)

# B-트리

- 자식을 2개만 갖는 이진 트리에서 확장되어 n개의 자식을 가질 수 있음
- 좌우 자식 간의 균형을 맞춤 → Balanced Tree
- 루트 노드, 브랜치 노드, 리프 노드로 구성
- 인덱스는 페이지 단위로 저장
- 인덱스 키를 바탕으로 항상 정렬된 상태를 유지
- 리프 노드에 (인덱스 키, PK) 쌍으로 저장

![image](https://github.com/cJinu/CS/assets/38110757/5a8ee25c-e2c0-4e79-b6ae-62aea108e81e)

## 페이지

- 메모리에 데이터를 읽고 쓰는 최소 작업 단위
- 인덱스뿐만 아니라 PK와 테이블은 대부분 페이지 단위로 관리

![image](https://github.com/cJinu/CS/assets/38110757/1e8f2cdd-ab3e-4f1f-8a4a-41f2c5883437)

## 장점

1. 조건 검색 WHERE 절의 효율성: 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건(WHERE)에 맞는 데이터들을 빠르게 탐색 가능(Full Scan 불필요)
2. 정렬 ORDER BY 절의 효율성: 이미 정렬되어 있다!!
3. MIN, MAX의 효율적인 처리: 레코드의 시작 값과 끝 값을 하나씩 가져오면 된다!!

## 단점

1. DML에 취약: 데이터 추가, 변경 및 삭제 시 테이블을 다시 정렬해야 함 → 검색 위주의 테이블이 인덱스에 적합
2. 더 많은 저장공간 필요: 인덱스 관리를 위해 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요
3. 테이블의 10~15% 이하의 데이터를 처리하는 경우에만 효율적!

# MySQL

- 클러스터형 인덱스
  - 테이블 당 하나
  - PK로 설정된 컬럼은 자동으로 클러스터링 인덱스가 생성
  - UNIQUE + NOT NULL
  - 실제 저장된 데이터와 같은 무리의 페이지 구조
  ![image](https://github.com/cJinu/CS/assets/38110757/f54f3b32-ef93-4fe1-815d-5aede43c04c0)
- 보조 인덱스

  - 한 테이블에 여러개 설정 가능
  - UNIQUE 키워드로 설정하면 자동으로 보조 인덱스가 생성
  - 실제 저장된 데이터와 다른 무리의 별도의 페이지 구조

  ![image](https://github.com/cJinu/CS/assets/38110757/9c485141-c81c-4924-89a6-889d28a172bb)
