# 🔒운영체제

# 3.3 프로세스와 스레드

`프로세스`

- 컴퓨터에서 실행되고 있는 **프로그램**. CPU 스케쥴링의 대상(task)
- 프로그램의 `인스턴스`
- 프로그램 하나에 여러 개의 프로세스가 존재할 수 있다. ex) 여러 개의 크롬

<aside>
💡 프로세서는 무엇인가?
프로세스를 처리하는 주체 (CPU)

</aside>

`스레드`

프로세스 내 작업의 **흐름**

## 3.3.1 프로세스와 컴파일 과정

`컴파일`

- 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 프로세스
- C언어 기반의 프로그램의 경우 컴파일 과정을 통해 기계어로 된 실행 가능한 파일이 생성된다.

### 컴파일 과정(C언어 기준)

1. 전처리
    - 전처리기 구문을 처리(#으로 시작하는 구문)
    - `.i` 파일
2. 컴파일러
    - 고수준언어를 저수준 언어로 변환
    - `.s` 파일
3. 어셈블러
    - 완전한 기계어로 변환
    - 목적 코드를 생성
    - `.o` 파일
4. 링커
    - 여러 개의 목적 코드 혹은 라이브러리를 병합하여 하나의 실행파일을 생성
    - `.exe` 혹은 `.out` 파일

### 라이브러리

`정적 라이브러리`

- 링커가 실행파일을 만들 때 외부 함수에 대한 정보를 실행파일에 복사
- 실행이 빠르고 별도의 라이브러리 파일이 필요하지 않다.
- 프로그램의 크기가 커지고 메모리 효율이 좋지 않다.

`동적 라이브러리`

- 코드가 복사되지 않고 프로그램 시작 시 로딩.
- 이미 메모리에 로딩되어 있다면 라이브러리 코드 영역 공유 가능
- 프로그램의 사이즈가 작다.
- 연결 시간이 존재하기 때문에 정적 라이브러리보다 느리다.

## 3.3.2 프로세스의 상태
![image](https://github.com/cJinu/CS/assets/77597885/f98539fe-9183-47ca-8b44-0ed3a2f13485)
프로세스는 위와 같이 상태 값을 갖는다. 

상태값은 스케줄링의 기준이 된다.

- **new(create) - 생성 상태**
    - 프로세스가 생성된 상태.
    - `fork()` 혹은 `exec()` 함수를 통해 생성
        > fork()  
        > - 부모 프로세스를 copy하여 새로운 프로세스를 생성하는 시스템 콜
        > - COW(Copy on write) 방식 사용 -> 리소스가 복제되었지만 수정되지 않은 경우에는 같은 리소스 공유, 수정되었을 경우 새로운 리소스 생성
        > ```c
            #include <stdio.h>
            #include <stdlib.h>
            #include <unistd.h>
             
            int main(){
                
                pid_t pid;
                int x = 1;
             
                pid = fork();
                if(pid == 0){ /*Child*/
                    printf("child: x=%d\n", ++x);
                    exit(0);
                }
             
                /*Parent*/
                printf("parent: x=%d\n", --x);
                exit(0);
            }
        ```
        > -
    - PCB가 할당되는 단계
- **ready- 대기 상태**
    - 프로그램을 실행할 준비가 된 상태
    - 프로세스가 메인 메모리로 로드 되는 단계
- **running - 실행 상태**
    - CPU에 의해 선택되어 실행 중인 상태
    - CPU burst가 일어났다고 표현하기도 한다.
        - CPU burst
            - CPU만 연속적으로 사용하면서 인스트럭션을 수행중인 상태.
            - I/O를 사용하면 I/O burst
            - CPU-burst time의 분포
                
               ![image](https://github.com/cJinu/CS/assets/77597885/90d521cf-1c97-44ab-8118-e0bc4d95a95a)
                
                - I/O burst의 빈도수가 높은 I/O bound job 의 시간이 짧고 빈도수 높다.
                - CPU burst의 빈도수가 높은 CPU burst job 은 시간이 길지만 빈도수가 낮다.