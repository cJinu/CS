# 3.3 프로세스와 스레드

`프로세스`

- 컴퓨터에서 실행되고 있는 **프로그램**. CPU 스케쥴링의 대상(task)
- 프로그램의 `인스턴스`
- 프로그램 하나에 여러 개의 프로세스가 존재할 수 있다. ex) 여러 개의 크롬

<aside>
💡 프로세서는 무엇인가?
프로세스를 처리하는 주체 (CPU)

</aside>

`스레드`

프로세스 내 작업의 **흐름**

## 3.3.1 프로세스와 컴파일 과정

`컴파일`

- 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 프로세스
- C언어 기반의 프로그램의 경우 컴파일 과정을 통해 기계어로 된 실행 가능한 파일이 생성된다.

### 컴파일 과정(C언어 기준)

1. 전처리
    - 전처리기 구문을 처리(#으로 시작하는 구문)
    - `.i` 파일
2. 컴파일러
    - 고수준언어를 저수준 언어로 변환
    - `.s` 파일
3. 어셈블러
    - 완전한 기계어로 변환
    - 목적 코드를 생성
    - `.o` 파일
4. 링커
    - 여러 개의 목적 코드 혹은 라이브러리를 병합하여 하나의 실행파일을 생성
    - `.exe` 혹은 `.out` 파일

### 라이브러리

`정적 라이브러리`

- 링커가 실행파일을 만들 때 외부 함수에 대한 정보를 실행파일에 복사
- 실행이 빠르고 별도의 라이브러리 파일이 필요하지 않다.
- 프로그램의 크기가 커지고 메모리 효율이 좋지 않다.

`동적 라이브러리`

- 코드가 복사되지 않고 프로그램 시작 시 로딩.
- 이미 메모리에 로딩되어 있다면 라이브러리 코드 영역 공유 가능
- 프로그램의 사이즈가 작다.
- 연결 시간이 존재하기 때문에 정적 라이브러리보다 느리다.

## 3.3.2 프로세스의 상태
![image](https://github.com/cJinu/CS/assets/77597885/f98539fe-9183-47ca-8b44-0ed3a2f13485)
프로세스는 위와 같이 상태 값을 갖는다. 

상태값은 스케줄링의 기준이 된다.

- **new(create) - 생성 상태**
    - 프로세스가 생성된 상태.
    - PCB가 할당되는 단계
- **ready- 대기 상태**
    - 프로그램을 실행할 준비가 된 상태
    - 프로세스가 메인 메모리로 로드 되는 단계
- **ready suspend - 대기 중단 상태**
  - 메모리 부족으로 일시 중단된 상태태
- **running - 실행 상태**
    - CPU에 의해 선택되어 실행 중인 상태
    - CPU burst가 일어났다고 표현하기도 한다.
        - CPU burst
            - CPU만 연속적으로 사용하면서 인스트럭션을 수행중인 상태.
            - I/O를 사용하면 I/O burst
            - CPU-burst time의 분포
                
               ![image](https://github.com/cJinu/CS/assets/77597885/90d521cf-1c97-44ab-8118-e0bc4d95a95a)
                
                - I/O burst의 빈도수가 높은 I/O bound job 의 시간이 짧고 빈도수 높다.
                - CPU burst의 빈도수가 높은 CPU burst job 은 시간이 길지만 빈도수가 낮다.
- **blocked - 중단 상태**
  - 특정 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
  - I/O 인터럽트로 인해 자주 발생
- **blocked suspend - 일시 중단 상태**
  - 중단된 상태에서 프로세스가 실행되려고 했으나 메모리 부족으로 일시 중단된 상태
- **exit - 종료 상태**
  - 프로세스가 완료되고 종류하기 직전의 상태

### 💡fork()
  - 부모 프로세스를 copy하여 새로운 프로세스를 생성하는 시스템 콜
  -  COW(Copy on write) 방식 사용 -> 리소스가 복제되었지만 수정되지 않은 경우에는 같은 리소스 공유, 수정되었을 경우 새로운 리소스 생성  
      ```c
      #fork 예시 코드
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
       
      int main(){
          
          pid_t pid;
          int x = 1;
       
          pid = fork();
          if(pid == 0){ /*Child*/
              printf("child: x=%d\n", ++x);
              exit(0);
          }
       
          /*Parent*/
          printf("parent: x=%d\n", --x);
          exit(0);
      }
      ```
  - fork()는 프로세스 id를 리턴한다. 부모에서는 자식 pid, 자식에서는 0이 반환된다.
  - 따라서 결과 값은
      ```
      parent: x=0
      child: x=2
      ```
  - 부모와 자식 중 어떤것이 먼저 출력될지는 알 수 없다 -> 스케쥴링 방식에 따라 다름.

## 3.3.3 프로세스의 메모리 구조
![image](https://github.com/cuzzzu1318/cuzzzu1318.github.io/assets/77597885/01276220-09b1-4927-857a-911569939925)
- 스택
  - 지역변수, 매개변수, 리턴값 등 잠시 사용되었다가 사라지는 데이터를 저장하는 영역
  - 컴파일 시 크기가 결정
- 힙
  - 동적으로 할당되는 변수들을 관리하는 영역
  - 메모리 주소 값에 의해서 참조되고 사용.
  - 런타임 시 크기가 결정
- 데이터
  - 전역변수와 정적변수가 저장되는 영역
  - 프로그램 시작 시 할당, 종료 시 소멸
  - BSS segment
    - 전역 변수 혹은 static, const
    - 0으로 초기화 혹은 초기화 되지 않은 변수
  - Data segment
    - 전역 변수 혹은 static, const
    - 0이 아닌 값으로 초기화 된 변수
- 코드
  - 프로그램의 코드가 저장됨.

## 3.3.4 PCB(Process Control Block)
![image](https://github.com/cuzzzu1318/cuzzzu1318.github.io/assets/77597885/7e5f8a4a-338f-4247-85f0-39b405e3d4fd)  
프로세스의 메타데이터를 저장한 데이터  
운영체제마다 다를 순 있지만 보통 위의 구조를 따른다.  
- 구조
  - Pointer
    - 프로세스의 현재 위치를 저장하는 포인터 정보
  - Process state
    - 프로세스의 상태
  - PID
    - 프로세스의 고유한 번호
  - Program Counter
    - 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터
  - Registers
    - 실행하기 위해 필요한 레지스터에 대한 정보
  - Memory Limits 
    - 운영체제에서 사용하는 메모리 관리 시스템에 대한 정보
    - 페이지 테이블, 세그먼트 테이블 등의 정보가 포함될 수 있다.
  - Open File Lists
    - 프로세스를 위해 열린 파일 목록
  - 프로세스 권한
    - 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
  - 스케쥴링 정보
    - 스케쥴러에 의해 중단된 시간 등에 대한 정보
  - 계정 정보
    - 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
  - I/O 상태 정보
    - 프로세스에 할당된 I/O디바이스 목록
- Context Switching(문맥 교환)
    ![image](https://github.com/cuzzzu1318/cuzzzu1318.github.io/assets/77597885/5e1575bc-b143-457e-baff-61573d3d2d33)
  - PCB를 교환하는 과정(CPU에서 실행될 프로세스를 교체하는 기술)
  - 많은 프로세스가 동시에 실행되는 것처럼 보이는 것은 빠른 속도로 컨텍스트 스위칭이 일어나기 때문
  - 멀티 태스킹
    - 프로세스 간 전환
  - 인터럽트 처리
    - 인터럽트 발생 시 컨텍스트 일부 전환
  - 커널모드 전환
    - 모드 간 전환이 필요할 때 컨텍스트 스위칭 발생 가능

  💡인터럽트
  - 프로세스 실행 도중 예기치 않은 상황 발생 시 해당 상황을 해결한 후 실행중인 작업으로 복귀하는 것
  - 외부 인터럽트
    - 주로 I/O 장치에 의해 발생
    - 타이머 인터럽트, 입출력 인터럽트
  - 내부 인터럽트
    - 하드웨어 고장
    - 실행할 수 없는 명령어

## 3.3.5 멀티 프로세싱
여러개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것.

### 웹 브라우저
- 웹 브라우저는 멀티프로세스 구조
 ![image](https://github.com/cuzzzu1318/cuzzzu1318.github.io/assets/77597885/55775d83-e5dd-4e27-a40b-63e9dda77cf6)

### IPC(Inter Process Communication)
- 프로세스 간 통신
- 공유 메모리
  - 통신이 아닌 데이터 자체를 공유
  - 프로세스가 공유 메모리 할당을 커널에 요청하면 해당 프로세스에게 메모리 공간을 할당
  - 이 후 해당 공간은 다른 프로세스가 접근 가능
  - 중개자가 없이 곧바로 접근할 수 있기 때문에 **모든 IPC 중에 가장 빠르다**
- 익명 파이프(PIPE)
  - 단방향의 읽기 혹은 쓰기 전용 파이프를 사용
  - 반이중통신이라고 부르기도 한다.
  - 부모 자식 프로세스 간에만 사용 가능. (통신할 프로세스가 명확한 경우)
  - 매우 간단하지만 전이중 통신을 구현하기 까다로움
- 명명된 파이프(Named PIPE)
  - 전혀 모르는 상태의 프로세스들 간 통신의 경우 사용
  - mkfifo 명령어를 통해 이루어짐 -> 명명된 파일 생성
  - 익명 파이프와 마찬가지로 읽기/쓰기가 동시에 되지 않음.
  - 명명된 파일이 있기 때문에 두 개의 FIFO파일로 전이중 통신 가능
- 메시지 큐
  - 메시지를 큐 형태로 관리하는 것
  - Named PIPE와 입출력 형태는 동일하지만 Named PIPE가 데이터의 흐름이라면 메시지 큐는 **메모리 공간**
  - 다른 IPC 방식에 비해 사용 방법이 간단하다.

## 3.3.6 스레드와 멀티 스레딩

### 스레드
![image](https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png)
- 프로세스의 실행 가능한 가장 작은 단위
- 프로세스는 여러 스레드를 가질 수 있다.
- 코드, 데이터, 힙은 서로 공유하고 그 외의 영역은 각각 생성

### 멀티 스레딩
- 프로세스 내 작업을 여러 개의 스레드로 처리하는 기법
- 자원을 공유하기 때문에 효율성이 높다.
- 동기화 문제가 발생할 수 있다. (자원을 공유하기 때문)
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

## 3.3.7 공유 자원과 임계 영역

### 공유자원
- 시스템 안에서 프로세스와 스레드가 함께 접근할 수 있는 자원이나 변수
- 해당 자원을 두 개 이상의 프로세스가 동시에 접근하는 상황을 `경쟁 상태(race condition)` 라고 한다.
  ![image](https://velog.velcdn.com/images/yh_lee/post/c6a34c53-b518-4d80-8e65-e502fa03d182/image.png)
- 실제 결과 값은 increase가 두 번 일어난 2여야 하지만 1로 인식 됨.

### 임계 영역
- 공유 자원에 접근할 때 순서등의 이유로 결과가 달라지는 코드 영역
- 경쟁상태에서 공유 자원을 사용하게 되는 영역

### 해결 조건
- 상호 배제(mutual exclusion)
  - 공용 데이터에 여러 개의 프로세스가 접근하는 상황을 막아야 한다.
- 한정 대기(bounded waiting)
  - 상호 배제 때문에 기다리게 되는 프로세스가 무한정 대기해서는 안된다.
- 진행 / 융통성 (progress / progress flexibility)
  - 한 프로세스가 다른 프로세스의 일을 방해해서는 안 된다.
  - 두 프로세스가 자원을 번갈아 쓰는 경우 한 쪽에서 자원을 쓰지 않는 데 다른 한 쪽이 자신의 turn이 아니라고 해서 기다리는 것은 효율적이지 못하다.
- 가장 단순한 해결 방법은 `Lock`

### 해결 방법
1. 뮤텍스(mutex)
   - Mutual Exclusion의 약자
   - 공유 자원을 사용할 때 lock을 통해 잠금 설정하고 사용한 이후에 unlock을 통해 잠금 해제하는 객체
   - 뮤텍스는 잠금 / 잠금 해제의 상태만 가진다.
2. 세마포어(semaphore)
   - 일반화된 뮤텍스
   - signal을 통해 상호배제를 달성하는 방법
   - `바이너리 세마포어` -> 0과 1의 두 가지 값만 가질 수 있는 세마포어
   - `카운팅 세마포어` -> 여러 개의 값을 가질 수 있는 세마포어로 여러 자원에 대한 접근을 제어하는 데에 사용
- 뮤텍스와 세마포어는 튜링 동치
  > 튜링 동치란?   
  > 컴퓨터 P와 Q가 있을 때 P가 할 수 있는 일을 Q가 모두 흉내낼 수 있고, 반대의 상황도 가능하다면 두 컴퓨터는 튜링 동치이다.
- 뮤텍스와 세마포어에 대한 쉬운 설명
  - https://worthpreading.tistory.com/90
- 두 방법 모두 완벽하지는 않으나 상호배제를 위한 기본적인 기법.
3. 모니터
   - 공유 자원을 숨기고 해당 접근에 대한 인터페이스만 제공
   - 모니터큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리
   - 세마포어보다 구현이 쉽고 상호배제가 자동

## 3.3.8 교착 상태 (deadlock)
두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FE7Ya4%2FbtrmiTF51TX%2FWfcOt6wUqore9ixmr3ASp0%2Fimg.png)

### 교착상태의 원인
1. 상호 배제
   - 하나의 프로세스가 자원을 독점하고 있어 다른 프로세스의 접근이 불가능하다.
2. 점유 대기
   - 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상황
3. 비선점
   - 다른 프로세스의 자원을 강제로 빼앗을 수는 없다. 점유하고 있는 프로세스가 해당 자원을 해제해야 한다.
4. 환형대기
   - 자원을 기다리는 프로세스간에 사이클이 형성된 상황
  
    ![image](https://github.com/cuzzzu1318/cuzzzu1318.github.io/assets/77597885/679109a7-69d2-46da-b274-a4d10e6cde00)
    > 출처: https://velog.io/@zioo/Deadlock%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EB%B0%9C%EC%83%9D-%EC%9B%90%EC%9D%B8

### 해결 방안
- 예방(prevention), 회피(avoidance)
  - 교착상태가 되지 않도록 설계한다.
  - 4개의 원인들 중 하나 이상을 부정하여 예방할 수 있다.
  - 회피에는 주로 은행원 알고리즘 사용
  - 회피 방법을 위한 가정들은 현실성이 부족
    - 프로세스 수가 고정되어 있어야 한다.
    - 자원의 종류와 수가 고정되어 있어야 한다.
    - 프로세스가 요구하는 자원 및 최대 자원의 수를 알아야 한다.
    - 프로세스는 반드시 자원을 사용 후 반납해야 한다.
  - 또한 자원 요청마다 회피 알고리즘을 사용하는 것은 상당한 오버헤드
- 탐지(detection) 및 복구(recovery)
  - 교착상태가 발생하면 해당 상황을 탐지하고 복구한다.
  - 지속적으로 확인하는 작업이 필요하다 -> 성능 저하
> 은행원 알고리즘  
> - 다익스트라가 제안한 방법
> - "은행은 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야한다" 라는 개념에서 출발
> - 교착상태에 빠질 가능성이 있는지 확인하기 위해 상태를 `안정 상태`와 `불안정 상태`로 나눈다
> - 자세한 설명: https://wookkingkim.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-The-Bankers-Algorithm